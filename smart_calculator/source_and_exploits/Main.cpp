#include "Collector.h"
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <cstdio>
#include <iostream>
#include <sys/wait.h> 
#include <csignal>
#include <algorithm>
#include <cstring>

#define EXPR_MAX_LEN 0x1f00
#define RESULT_MAX_LEN 0X1f00
#define ID_MAX_LEN 0x2010

pid_t g_pid_identify;
int g_message_queue_id;

void message_queue_init() {
    srand(time(NULL));
    int rand_key = rand();
    g_message_queue_id = msgget(rand_key, IPC_CREAT | IPC_EXCL | O_RDWR | 0644);
    if (g_message_queue_id == -1) {
        perror("msgget");
        exit(1);
    }
}

void signal_kill(int signum) {
    int status;
    wait(&status);
    destory_message_queue(g_message_queue_id);
    exit(0);
}

int check_legal(char *str, int len) {
    for (int i = 0; i < len; i++) {
        if ((!isprint((int)str[i])) && str[i] != '\n') {
            return 0;
        }
    }
    return 1;
}

int main() {
    setbuf(stdout, NULL);
    setbuf(stdin, NULL);
    setbuf(stderr, NULL);

    message_queue_init();
    if ((g_pid_identify = fork()) == 0) {
        run_server(g_message_queue_id);
        exit(0);
    }
    signal(SIGINT, signal_kill);
    while (true) {
        char solver_id[ID_MAX_LEN] = {0};
        char expression[EXPR_MAX_LEN] = {0};
        char result[RESULT_MAX_LEN] = {0};
        size_t solver_id_len = 0;
        size_t result_len = 0;
        size_t expr_len = 0;
        
        std::cout << "Input solver_id> ";
        solver_id_len = read(0, solver_id, ID_MAX_LEN);
        if (solver_id_len >= ID_MAX_LEN) {
            std::cout << "solver_id should not longer than [" << ID_MAX_LEN << "] !" << std::endl;
            continue;
        }

        if (!strncmp(solver_id, "3x1t", 4)) {
            int status;
            push_cmd(g_message_queue_id, solver_id, 4);
            wait(&status);
            exit(0);
        }

        std::cout << "Input expression> ";
        expr_len = read(0, expression, EXPR_MAX_LEN);
        if (!check_legal(expression, expr_len)) {
            std::cout << "Not a legal string!" << std::endl;
            continue;
        }
        if (expr_len >= EXPR_MAX_LEN) {
            std::cout << "expression should not longer than [" << EXPR_MAX_LEN << "] !" << std::endl;
            continue;
        }

        std::cout << "Input result> ";
        result_len = read(0, result, RESULT_MAX_LEN);
        if (!check_legal(result, result_len)) {
            std::cout << "Not a legal string!" << std::endl;
            continue;
        }
        if (result_len >= RESULT_MAX_LEN) {
            std::cout << "result should not longer than [" << RESULT_MAX_LEN << "] !" << std::endl;
            continue;
        }

        push_cmd(g_message_queue_id, solver_id, solver_id_len);
        push_cmd(g_message_queue_id, expression, expr_len);
        push_cmd(g_message_queue_id, result, result_len);
        sleep(1);
    }
}