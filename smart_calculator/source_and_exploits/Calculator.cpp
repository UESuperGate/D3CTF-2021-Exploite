#include "Calculator.h"

const CCalculator::SOP CCalculator::s_OP[EOP_OPCNT] = {{'+', EOP_PLUS}, {'-', EOP_MINUS}, \
{'*', EOP_MULTI}, {'/', EOP_DIVID}, {'(', EOP_LBRACKET}, {')', EOP_RBRACKET}, {'#', EOP_SHAP}};

const char  CCalculator::s_OpPriorityTable[EOP_OPCNT][EOP_OPCNT] = 
                                  {
                                    {'>','>','<','<','<','>','>'},
                                    {'>','>','<','<','<','>','>'},
                                    {'>','>','>','>','<','>','>'},
                                    {'>','>','>','>','<','>','>'},
                                    {'<','<','<','<','<','=',' '}, 
                                    {'>','>','>','>',' ','>','>'},
                                    {'<','<','<','<','<',' ','='}
                                  };

CCalculator::CCalculator(void)
 : m_EquationErr(false)
{

}

CCalculator::~CCalculator(void)
{
}

const float CCalculator::CalcEquation(string &eq)
{
    if (eq.empty())
    {

        return 0.0f;
    }
    size_t idx = eq.find_first_of("=");  
    if (idx != string::npos)              
    {
      eq[idx] = ' ';
    }
    while(!m_NumStack.empty()) m_NumStack.pop();
    while(!m_OptrStack.empty()) m_OptrStack.pop();
    m_OptrStack.push('#');
    m_EquationErr = false;
    eq.append("#");

    float tmpNum = 0.0f; 
    char  tmpOp  = ' '; 
    int   curIdx = 0; 
    bool  numAdj = false;
    istringstream is(eq);
    while (!is.eof() && tmpOp != '#')
    {
        char c;
        if ((curIdx = is.tellg()) == string::npos)
        {
            break;
        }
        c = (is.str())[curIdx];
        if (c >= '0' && c <= '9')
        {
            if (numAdj)
            {
                cout << "Calc/> The equation you input is wrong!" << endl;
                return 0.0f;
            }
            tmpNum = 0;
            is >> tmpNum;
            m_NumStack.push(tmpNum);
            numAdj = true;              
        }
        else if (IsOperator(c))
        {
            tmpOp = ' ';
            is >> tmpOp;
            char priority = ' ';
            numAdj = false;
            do 
            {
                priority = ComparePriority(m_OptrStack.top(), tmpOp);
                if (priority == ' ' || m_EquationErr)
                {
                    cout << "Calc/> The equation you input is wrong!" << endl;
                    return 0.0f;
                }
            } while (!OperateDependOnPriority(priority, tmpOp));

        }
        else if (c == ' ')
        {
            is.seekg(curIdx+1, ios::beg);
        }
        else    
        {
            cout << "Calc/> The equation you input is wrong!" << endl;
            return 0.0f;
        }
    }

    if (!m_OptrStack.empty() || m_NumStack.size() != 1)
    {
        cout << "Calc/> The equation you input is wrong!" << endl;
        return 0.0f;
    }
    return m_NumStack.top();
}

bool CCalculator::IsOperator(char c) const
{
    return FindOperatorIdx(c) < EOP_OPCNT ? true : false;
}

int CCalculator::FindOperatorIdx(char c) const
{
    int i = 0;
    while (c != s_OP[i].op && i < EOP_OPCNT)
    {
        i++;
    }

    return i;
}

char CCalculator::ComparePriority(char bcp, char cp) const
{
    int bidx = FindOperatorIdx(bcp);
    if (bidx >= EOP_OPCNT)
    {
        return ' ';
    }
    int cidx = FindOperatorIdx(cp);
    if (cidx >= EOP_OPCNT)
    {
        return ' ';
    }
    return s_OpPriorityTable[bidx][cidx];
}

bool CCalculator::OperateDependOnPriority(const char priority, char op)
{
    switch (priority)
    {
    case '<':
        m_OptrStack.push(op);
        return true;
    case '>':
        {
            if (m_NumStack.size() < 2) 
            {
                m_EquationErr = true;
                return false;
            }
            float rhs = m_NumStack.top();m_NumStack.pop();
            float lhs = m_NumStack.top();m_NumStack.pop();
            m_NumStack.push(Operate(lhs, m_OptrStack.top(), rhs));
            m_OptrStack.pop();
            return false;
        }
    case '=':
        m_OptrStack.pop();
        return true;
    default:
        m_EquationErr = true;
        break;
    }
    return false;
}
