#include "Collector.h"
#include "Calculator.h"

#include <iostream>
#include <cstdio>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <fstream>
#include <string>
#include <sys/stat.h>
#include <fcntl.h>
#include <algorithm>
#include <unistd.h> 
#include <unordered_map>
#include <cstring>

#define EXPR_MAX_LEN 0x2000
#define RESULT_MAX_LEN 0X100
#define ID_MAX_LEN 0x2000

typedef struct HELPER {
    uint8_t expression[EXPR_MAX_LEN];
    uint8_t result[RESULT_MAX_LEN];
}helper;

void generate_result_banner(const char *your_result, const char *real_result) {

}

void handler_for_each(
    std::pair<char *, size_t> p1, 
    std::pair<char *, size_t> p2,
    std::pair<char *, size_t> p3) {

    CCalculator c;
    std::string expr;
    float r, _or;
    helper h;
    // memset(&h, 0, sizeof(h));

    memcpy(&h.result, p2.first, p2.second);
    memcpy(&h.expression, p3.first, p3.second);

    expr = std::string((char *)&h.expression);
    // std::cout << "[DEBUG] " << "your expression: " << expr << std::endl;
    r = c.CalcEquation(expr);
    _or = std::atof((char *)&h.result);
    // std::cout << "[DEBUG] " << "real result: " << r << std::endl;
    // std::cout << "[DEBUG] " << "your result: " << _or << std::endl;
    if (std::abs(r - _or) < 0.0001) {
        std::cout << std::string(p1.first) << ": " << "Good calculating!" << std::endl;
    }
    else {
        std::cout << std::string(p1.first) << ": " << "Your result is: " << std::endl;
        write(1, &h.result, p2.second + 0x40);
        std::cout << " which is incorrect..." << std::endl;
    }


        
}

void run_server(const int mq_id) {
    while(true) {
        std::pair<char *, size_t> p1, p2, p3;
        p1 = pop_cmd(mq_id);
        if (!strncmp(p1.first, "3x1t", 4)) {
            destory_message_queue(mq_id);
            exit(0);
        }
        p2 = pop_cmd(mq_id);
        p3 = pop_cmd(mq_id);
        // printf("[Received id]: %s\n", p1.first);
        // printf("[Received result]: %s\n", p2.first);
        // printf("[Received expression]: %s\n", p3.first);

        handler_for_each(p1, p3, p2);

        free(p1.first);
        free(p2.first);
        free(p3.first);
    }
}